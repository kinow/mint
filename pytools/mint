#!/usr/bin/env python

import defopt
from pathlib import Path
import numpy
import mint
import netCDF4


def generate_lonlat_grid(*, nx: int = 10, ny: int = 5, grid_file: Path = '', grid_name: str='lonlat_mesh'):
    """Generate lon-lat grid

    :param nx: number of longitude cells
    :param ny: number of latitude cells
    :grid_file: name of the output UGRID2D file
    """
    if str(grid_file.name) is '.':
        raise RuntimeError('ERROR: must specify grid file')

    nc = netCDF4.Dataset(grid_file, 'w')

    nx1, ny1 = nx + 1, ny + 1
    nnodes = nx1 * ny1
    nedges = nx*ny1 + nx1*ny
    nfaces = nx * ny
    nnodesId = nc.createDimension('nnodes', nnodes)
    nedgesId = nc.createDimension('nedges', nedges)
    nfacesId = nc.createDimension('nfaces', nfaces)
    fourId = nc.createDimension('four', 4)
    twoId = nc.createDimension('two', 2)

    mesh = nc.createVariable(grid_name, "int", [])
    mesh.cf_role = 'mesh_topology'
    mesh.topology_dimension = 2
    mesh.node_coordinates = 'lon lat'
    mesh.face_node_connectivity = 'face_node'
    mesh.face_edge_connectivity = 'face_edge'
    mesh.edge_node_connectivity = 'edge_node'


    faceNodeConn = nc.createVariable("face_node", "int64", ("nfaces", "four"))
    faceNodeConn.cf_role = "face_node_connectivity"
    faceNodeConn.start_index = 0

    faceEdgeConn = nc.createVariable("face_edge", "int64", ("nfaces", "four"))
    faceEdgeConn.cf_role = "face_edge_connectivity"
    faceEdgeConn.start_index = 0

    edgeNodeConn = nc.createVariable("edge_node", "int64", ("nedges", "two"))
    edgeNodeConn.cf_role = "node_edge_connectivity"
    edgeNodeConn.start_index = 0

    xvar = nc.createVariable("lon", "float64", ("nnodes",))
    xvar.standard_name = "longitude"
    xvar.units = "degrees_east"

    yvar = nc.createVariable("lat", "float64", ("nnodes",))
    yvar.standard_name = "latitude"
    yvar.units = "degrees_north"

    # set the lats/lons
    lats = numpy.zeros((nnodes,), numpy.float64)
    lons = numpy.zeros((nnodes,), numpy.float64)
    dlat, dlon = 180./float(ny), 360.0/float(nx)
    for j in range(ny1):
        for i in range(nx1):
            index = i + nx1*j
            lons[index] = 0.0 + i*dlon
            lats[index] = -90.0 + j*dlat
            x, y = lons[index], lats[index]
    xvar[:] = lons
    yvar[:] = lats

    # face-node connectivity
    fn = numpy.zeros((nfaces, 4), numpy.int64)
    count = 0
    for j in range(ny):
        for i in range(nx):
            i00 = i + 0 + nx1*(j + 0)
            i10 = i + 1 + nx1*(j + 0)
            i11 = i + 1 + nx1*(j + 1)
            i01 = i + 0 + nx1*(j + 1)
            fn[count, :] = i00, i10, i11, i01
            count += 1
    faceNodeConn[...] = fn

    # edge-node connectivity
    en = numpy.zeros((nedges, 2), numpy.int64)

    # x edges
    count = 0
    for j in range(ny + 1):
        for i in range(nx):
            i00 = i + 0 + nx1*(j + 0)
            i10 = i + 1 + nx1*(j + 0)
            en[count, :] = i00, i10
            count += 1

    # y edges
    for j in range(ny):
        for i in range(nx + 1):
            i00 = i + 0 + nx1*(j + 0)
            i01 = i + 0 + nx1*(j + 1)
            en[count, :] = i00, i01
            count += 1

    edgeNodeConn[...] = en

    # face-edge connectivity
    fe = numpy.zeros((nfaces, 4), numpy.int64)
    count = 0
    for j in range(ny):
        for i in range(nx):
            is0 = 0 + i + 0 + (nx + 0)*(j + 0)
            is1 = 0 + i + 0 + (nx + 0)*(j + 1)
            i0s = nx*ny1 + i + 0 + nx1*(j + 0)
            i1s = nx*ny1 + i + 1 + nx1*(j + 0)
            fe[count, :] = is0, i1s, is1, i0s
            count += 1
    faceEdgeConn[...] = fe

    nc.close()



def compute_weights(*, src_grid_file: Path = '', src_grid_name: str = '', src_grid_flag: int = 0, 
                       dst_grid_file: Path = '', dst_grid_name: str = '', dst_grid_flag: int = 0,
                       weights_file: Path = '', periodx : float = 360.):
    """Compute the regridding weights

    :param src_grid_file: name of the file holding the source grid
    :param src_grid_name: name of the source grid stored in the netCDF file
    :param src_grid_flags: use 0 for lat-lon and 1 for cubed-sphere
    :param dst_grid_file: name of the file holding the destination grid
    :param dst_grid_name: name of the destination grid stored in the netCDF file
    :param dst_grid_flags: use 0 for lat-lon and 1 for cubed-sphere
    :param weights_file: netCDF file that will hold the regridding weights
    :param periodx: periodicity in longitudes, can be 0 if non-periodic
    """

    # create a regridder
    rg = mint.RegridEdges()

    # 0, 0 does not apply any transformations to the grid (appropriate for lat-lon).
    # All other grid types should apply (1, 1)
    rg.setSrcGridFlags(0, 0)
    if src_grid_flag:
        rg.setSrcGridFlags(1, 1)

    if str(src_grid_file.name) is '.':
        raise RuntimeError('ERROR: must specify source grid file')
    if src_grid_name is '':
        raise RuntimeError('ERROR: must specify source grid name')
    if not src_grid_file.exists():
        raise RuntimeError(f'ERROR: source grid file {src_grid_file} does not exist')

    # load the src grid
    fn = str(src_grid_file) + ':' + src_grid_name
    print(f'info: loading {fn}')
    rg.loadSrcGrid(fn)
    print('Done.')

    # 0, 0 does not apply any transformations to the grid (appropriate for lat-lon).
    # All other grid types should apply (1, 1)
    rg.setDstGridFlags(0, 0)
    if dst_grid_flag:
        rg.setDstGridFlags(1, 1)

    if str(dst_grid_file) is '.':
        raise RuntimeError('ERROR: must specify destination grid file')
    if dst_grid_name is '':
        raise RuntimeError('ERROR: must specify destination grid name')
    if not dst_grid_file.exists():
        raise RuntimeError(f'ERROR: destination grid file {dst_grid_file} does not exist')

    # load the dst grid
    fn = str(dst_grid_file) + ':' + dst_grid_name
    print(f'info: loading {fn}')
    rg.loadDstGrid(fn)
    print('Done.')

    # compute the regridding weights. numCellsPerBucket is used to accelerate the cell
    # search. The smaller numCellPerBucket the faster the search. However, there are
    # edge cases where the search fails when numCellsPerBucket is too small.
    # periodX is the periodicity length that will be added/subtracted to make the cells well behaved. 
    # (set periodX = 0 in a regional model away from the dateline)
    rg.build(numCellsPerBucket=128, periodX=periodx, debug=2)

    if str(weights_file) is not '.':
        # save the weights in a netCDF file
        print(f'info: saving weights in file {weights_file}')
        rg.dumpWeights(str(weights_file))
        

def apply_weights(*, weights_file: Path = '', field_name: str = '',
                     src_field_file: Path = '', dst_field_file: Path = ''):
    """Apply the regridding weights

    :param weights_file: netCDF file that will hold the regridding weights
    :param field_name: name of the field in the source field file
    :param src_field_file: name of the source field file
    :param dst_field_file: name of the destination field file
    """

    # create a regridder
    rg = mint.RegridEdges()

    if str(weights_file) is '.':
        raise RuntimeError('ERROR: must specify a weights file')
    if field_name is '':
        raise RuntimeError('ERROR: must specify a field name')
    if str(src_field_file) is '.':
        raise RuntimeError('ERROR: must specify a source field file')
    if str(dst_field_file) is '.':
        raise RuntimeError('ERROR: must specify a destination field file')

    rg.loadWeights(str(weights_file))

    numSrcEdges = rg.getNumSrcEdges()
    numDstEdges = rg.getNumDstEdges()

    srcData = numpy.zeros((numSrcEdges,), numpy.float64)
    dstData = numpy.zeros((numDstEdges,), numpy.float64)

    # initialize the slices by reading the metcdf metadata from file
    append = 0; # new file
    numSlices = rg.initSliceIter(src_field_file, dst_field_file, append, field_name)

    for i in range(numSlices):

        rg.loadSrcSlice(srcData);
        rg.apply(srcData, dstData)
        rg.dumpDstSlice(dstData);
        rg.nextSlice()



def polyline_integral(*, src_grid_file: Path = '', src_grid_name: str = '', src_grid_flag: int = 0,
                         src_field_name: str = 'u',
                         points: str = '(0., -90.),(360., 90.)', 
                         periodx : float = 360.):
    """Compute the polyline flux integral

    :param src_grid_file: name of the file holding the source grid
    :param src_grid_name: name of the source grid
    :param src_grid_flags: use 0 for lat-lon and 1 for cubed-sphere
    :param src_field_name: name of the field
    :param points: target points as a string in lon-lat space, e.g. '(0., -90.),(360., 90.)'
    :param periodx: periodicity in longitudes, can be 0 if non-periodic
    :returns: flux integral
    """

    grd = mint.Grid()
    gr.setFlags(0, 0)
    if src_grid_flag:
        gr.setFlags(1, 1)

    gr.loadFrom2DUgrid(src_grid_file + ':' + src_grid_name)

    pli = mint.PolylineIntegral()

    # create the polyline through which the flux will be integrated
    xyz = numpy.array(eval(points))

    pli.build(gr, xyz, counterclock=False, periodX=periodx)

    flux = pli.getIntegral(data)
    print(f'total flux: {flux:.3f}')


if __name__ == '__main__':
    defopt.run([generate_lonlat_grid, compute_weights, apply_weights, polyline_integral])
