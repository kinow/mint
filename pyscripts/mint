#!/usr/bin/env python

import defopt
from pathlib import Path
import numpy
import mint

def compute_weights(*, src_grid_file: Path = '', src_grid_name: str = '', src_grid_flag: int = 0, 
                              dst_grid_file: Path = '', dst_grid_name: str = '', dst_grid_flag: int = 0,
                              weights_file: Path = '', periodx : float = 360.):
    """Compute weights

    :param src_grid_file: name of the file holding the source grid
    :param src_grid_name: name of the source grid stored in the netCDF file
    :param src_grid_flags: use 0 for lat-lon and 1 for cubed-sphere
    :param dst_grid_file: name of the file holding the destination grid
    :param dst_grid_name: name of the destination grid stored in the netCDF file
    :param dst_grid_flags: use 0 for lat-lon and 1 for cubed-sphere
    :param weights_file: netCDF file that will hold the regridding weights
    :param periodx: periodicity in longitudes, can be 0 if non-periodic
    """
    # create a regridder
    rg = mint.RegridEdges()


    # 0, 0 does not apply any transformations to the grid (appropriate for lat-lon).
    # All other grid types should apply (1, 1)
    rg.setSrcGridFlags(0, 0)
    if src_grid_flag:
        rg.setSrcGridFlags(1, 1)

    # load the src grid
    rg.loadSrcGrid(src_grid_file + ':' + src_grid_name)

    # 0, 0 does not apply any transformations to the grid (appropriate for lat-lon).
    # All other grid types should apply (1, 1)
    rg.setDstGridFlags(0, 0)
    if dst_grid_flag:
        rg.setDstGridFlags(1, 1)

    # load the dst grid
    rg.loadDstGrid(dst_grid_file + ':' + dst_grid_name)

    # compute the regridding weights. numCellsPerBucket is used to accelerate the cell
    # search. The smaller numCellPerBucket the faster the search. However, there are
    # edge cases where the search fails when numCellsPerBucket is too small.
    # periodX is the periodicity length that will be added/subtracted to make the cells well behaved. 
    # (set periodX = 0 in a regional model away from the dateline)
    rg.build(numCellsPerBucket=128, periodX=periodx, debug=2)

    if weights_file:
        # save the weights in a netCDF file
        rg.dumpWeights(weights_file)
        


def polyline_integral(*, src_grid_file: Path = '', src_grid_name: str = '', src_grid_flag: int = 0,
                         src_field_name: str = 'u',
                         points: str = '(0., -90.),(360., 90.)', 
                         periodx : float = 360.):
    """Compute the polyline flux integral

    :param src_grid_file: name of the file holding the source grid
    :param src_grid_name: name of the source grid
    :param src_grid_flags: use 0 for lat-lon and 1 for cubed-sphere
    :param src_field_name: name of the field
    :param points: target points as a string in lon-lat space, e.g. '(0., -90.),(360., 90.)'
    :param periodx: periodicity in longitudes, can be 0 if non-periodic
    :returns: flux integral
    """

    grd = mint.Grid()
    gr.setFlags(0, 0)
    if src_grid_flag:
        gr.setFlags(1, 1)

    gr.loadFrom2DUgrid(src_grid_file + ':' + src_grid_name)

    pli = mint.PolylineIntegral()

    # create the polyline through which the flux will be integrated
    xyz = numpy.array(eval(points))

    pli.build(gr, xyz, counterclock=False, periodX=periodx)

    flux = pli.getIntegral(data)
    print(f'total flux: {flux:.3f}')


if __name__ == '__main__':
    defopt.run([compute_weights, polyline_integral])
